# Architecture

## Main System Components

### Puzzle Generator & (Optional) Proof Builder (Server)

"generate_puzzle"
- Generates a crossword puzzle `PuzzleData` with list of slots[]: clue, solution, position (x,y), type (across|down)
- Generates merkle root of all slots in `PuzzleData`. The Merkle root is generated by ordering the solutions and create a merkle tree.
- Returns puzzle data on request, including Merkle root commitment.
- There are 2 types of puzzles: "hash-cryptic" and "server-proof" that describes how slot correctness proofs are handles
    - hash-cryptic: The slot "solution" is provided in the generate_puzzle response, but hashed with Poseiden. These games use cryptic words that are not found in dictionaries. The client browser locally proves that their guess matches the poseiden solution.
    - server-proof: The slot "solution" is null, and only the length is provided in slot response. The client browser must submit a request to "build_proof" on the server in order to retrieve a proof-of-correctness for each slot.

"build_proof"
- server endpoint that accepts a user solution and builds a proof for server-proof type puzzles
- server endpoint is rate limited to X requests/per IP/per minute

### Client (Browser)
- requests `PuzzleData` from Server, renders grid
- coordinates requests to `build_proof` endpoint, providing user inputs and receiving proof
- submits proof to `WordWiz` contract with wallet credentials

### Proof Verifier (on-chain)
- verifying function for proofs

### WordWiz Contract
- verifies submitted proofs and executes relevant logic (TBD)

## Decisions

Rationale on whether to prove client-side or server-side:

- client-side proving requires the server provide a `hash(solution)` per slot which can be brute forced offline using dictionary words and the solution length. One mitigation is to use cryptic or non-dictionary words, altering the game mechanics slightly. Maybe AI can solve most puzzles anyway, so cryptic/new word compositions are necessary.

- server-side proving can also be brute-forced but a throttling layer can be introduced to mitigate (rate-limiting, proof of work, payments).

- server-side proving introduces trust assumptions of honesty, requires server to be available and internet connection or the game stops.